# Домашнее задание к лекции "Работа в терминале. Часть 2"

## 1. Какого типа команда cd ? Попробуйте объяснить, почему она именно такого типа.

Команда `cd` является встроенной в оболочку командой, потому что на запрос типа об этом говорится явно:

```console
vagrant@vagrant:~$ type cd
cd is a shell builtin
vagrant@vagrant:~$
```

Команда предназначена для изменения рабочего каталога. Если команда была бы отдельной программой, то при её выполнении (например: `cd ~/my_test`) запускался бы дочерний процесс, который менял рабочий каталог в своём окружении. После завершения этого процесса, мы не получили бы никаких изменений в своём окружении, то есть наш рабочий каталог не изменился бы.

---

## 2. Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l?

Команда `grep <some_string> <some_file>` выведет из файла `<some_file>` строки, содержащие `<some_string>`. Команда `wc -l` выведет число строк. Однако у команды `grep` есть ключ `-c` выполняющий туже функцию, то есть использование `pipe` в данном случае бессмысленно.

Подобная конструкция эквивалентна выражению: `grep -c <some_string> <some_file>`

---

## 3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

Родителем для всех процессов является `systemd`

```console
vagrant@vagrant:~$ pstree -p -T
systemd(1)─┬─VBoxService(838)
           ├─accounts-daemon(630)
           ├─atd(665)
           ├─cron(655)
           ├─dbus-daemon(631)
           ├─fwupd(1160)
           ├─irqbalance(639)
           ├─login(681)───bash(1012)
           ├─multipathd(527)
           ├─networkd-dispat(640)
           ├─polkitd(713)
           ├─rsyslogd(641)
           ├─snapd(644)
           ├─sshd(703)───sshd(1240)───sshd(1281)───bash(1282)───pstree(1344)
           ├─systemd(1006)───(sd-pam)(1007)
           ├─systemd-journal(357)
           ├─systemd-logind(646)
           ├─systemd-network(613)
           ├─systemd-resolve(615)
           ├─systemd-udevd(387)
           ├─udisksd(647)
           └─upowerd(1165)
vagrant@vagrant:~$
```

---

## 4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?

`stderr` - это стандартный поток ошибок

Под сессиями терминала можно понимать как эмуляторы терминала TTY - они представлены файлами устройств `/dev/tty*`, так и псевдоэмуляторы терминалов PTY, которые представляются файлами устройств `/dev/ptmx` и `/dev/pts/*`

Стандартные потоки: `stdin` или `ввода` = 0, `stdout` или `вывода` = 1, `stderr` или `ошибок` = 2

Таким образом перенаправить вывод стандартного потока ошибок команды `ls` в другую сессию терминала можно следующим образом:

- для эмуляторов терминала TTY: `ls <параметры> 2>/dev/tty<номер_терминала>`, например если мы находимся в эмуляторе терминале TTY1 и хотим передать в эмулятор TTY2: `ls dir_which_not_exists 2>/dev/tty2`

- для пседвоэмуляторов терминала PTY: `ls <параметры> 2>/dev/pts/<номер_терминала>`, например если мы находимся в слейве псевдотерминала 0 и хотим передать в слейв псевдотерминала 1: `ls dir_which_not_exists 2>/dev/pts/1`

- конечно, возможна и перекрёстная передача из TTY в терминал SSH сессии и наоборот

---

## 5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл?

Получится. Нужно просто корректно указать перенаправление для `stdin` и `stdout` следующим образом:

`command < input_file > output_file`

Например: `grep STR <aa.sh >aa_grep_result` - в команду `grep` для поиска строк содержащих `STR` будут переданы данные из файла `aa.sh` (символ `<` обозначающий `stdin`), а результат будет перенаправлен в файл `aa_grep_result` (символ `>` без указания потока обозначает `stdout`)

---

## 6. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

Такое возможно. Например, находять в окне удалённого подключения по SSH (графическое представление PTY) к виртуальной машине можно выполнить команду `echo "Hello from PTY" >/dev/tty1`, которая осуществит вывод фразы `Hello from PTY` в эмулятор терминала TTY1 виртуальной машины. Увидеть эту фразу можно непосредственно в самой виртуальной машине. Для этого предварительно её можно запустить при помощи GUI VirtualBox и авторизоваться после загрузки. По умолчанию мы будем в эмуляторе терминала TTY1. Второй (TTY2) активируется клавишами Ctrl+Alt+F2 и т.д. 

---

## 7. Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?

Команда: `bash 5>&1` должна запустить дочерний процесс `bash` и перенаправить поток `5` (создать) на стандартный `stdout`. После выполнения команды мы переключимся на созданный экземпляр `bash`.

Данное поведение хорошо демонстрируют следующие команды:
```console
vagrant@vagrant:~$ pstree -pT
systemd(1)─┬─VBoxService(840)
           ├─accounts-daemon(627)
           ├─atd(660)
           ├─cron(654)
           ├─dbus-daemon(628)
           ├─irqbalance(634)
           ├─login(681)───bash(1196)
           ├─login(1205)───bash(1234)
           ├─multipathd(526)
           ├─networkd-dispat(635)
           ├─polkitd(705)
           ├─rsyslogd(636)
           ├─snapd(640)
           ├─sshd(696)───sshd(977)───sshd(1043)───bash(1044)───pstree(1437)
           ├─systemd(1009)───(sd-pam)(1010)
           ├─systemd-journal(353)
           ├─systemd-logind(643)
           ├─systemd-network(611)
           ├─systemd-resolve(613)
           ├─systemd-udevd(385)
           └─udisksd(644)
vagrant@vagrant:~$

```
Изначально мы находимся в процессе с PID **1044**, что видно по выводу команды, так как мы должны являться родителем процесса `pstree` **1437**

После выполнения команды `bash 5>&1` дерево процессов примет следующий вид:
```console
vagrant@vagrant:~$ pstree -pT
systemd(1)─┬─VBoxService(840)
           ├─accounts-daemon(627)
           ├─atd(660)
           ├─cron(654)
           ├─dbus-daemon(628)
           ├─irqbalance(634)
           ├─login(681)───bash(1196)
           ├─login(1205)───bash(1234)
           ├─multipathd(526)
           ├─networkd-dispat(635)
           ├─polkitd(705)
           ├─rsyslogd(636)
           ├─snapd(640)
           ├─sshd(696)───sshd(977)───sshd(1043)───bash(1044)───bash(1443)───pstree(1450)
           ├─systemd(1009)───(sd-pam)(1010)
           ├─systemd-journal(353)
           ├─systemd-logind(643)
           ├─systemd-network(611)
           ├─systemd-resolve(613)
           ├─systemd-udevd(385)
           └─udisksd(644)
vagrant@vagrant:~$
```
То есть, процесс **1044** породил процесс `bash` с PID **1443**

У процесса открыты следующие файловые дескритпоры:

```console
vagrant@vagrant:~$ ls -l /proc/$$/fd
total 0
lrwx------ 1 vagrant vagrant 64 Feb  9 10:20 0 -> /dev/pts/0
lrwx------ 1 vagrant vagrant 64 Feb  9 10:20 1 -> /dev/pts/0
lrwx------ 1 vagrant vagrant 64 Feb  9 10:20 2 -> /dev/pts/0
lrwx------ 1 vagrant vagrant 64 Feb  9 10:20 255 -> /dev/pts/0
lrwx------ 1 vagrant vagrant 64 Feb  9 10:20 5 -> /dev/pts/0
vagrant@vagrant:~$
```

Если выполнить команду `echo netology > /proc/$$/fd/5`, то слово `netology` выведется в окне текущего терминала.
Если разбирать детально, то произойдёт следующее:
1. Запустится встроенная в shell команда `echo` которая захочет отправить в `stdout` текущего процесса **1443** слово `netology`
2. Так как при исполнении команды указано перенаправление стандартного потока `stdout` (`>`), то вывод пойдёт, грубо говоря, на файловый дескриптор `5` текущего процесса (`/proc/$$/`), а именно bash с PID **1443**
3. Но до этого, поток `5` был направлен на `stdout` родительского процесса, а именно bash с PID **1044**, который и выведет на экран слово `netology`

---

## 8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty?

Получится.

Допустим, у нас есть несколько файлов:

```console
vagrant@vagrant:~/test$ ls
1.dat  2.dat  3.dat  5.dat  6.dat  7.dat  8.dat  9.dat
vagrant@vagrant:~/test$
```

Каждый из них содержит словесное представление имени файла на английском языке, то есть файл `1.dat` содержит `one`, `2.dat` содержит `"two"` и т.п.

Мы хотим вывести содержимое всех файлов, а также вывести сколько файлов из диапазона `1..10` отстствует.

Для этого мы можем использовать следующую команду: `cat {1..10}.dat 2>&1 >$(tty) | echo "Not found $(wc -l) files"`

```console
vagrant@vagrant:~/test$ cat {1..10}.dat 2>&1 >$(tty) | echo "Not found $(wc -l) files"
one
two
three
five
six
seven
eight
nine
Not found 2 files
vagrant@vagrant:~/test$
```

С использованием промежуточного потока аналогично предудущей задачи команды будут выглядеть следующим образом:

```console
vagrant@vagrant:~/test$ bash 5>&1
vagrant@vagrant:~/test$ cat {1..10}.dat 2>&1 >&5 | echo "Not found $(wc -l) files"
one
two
three
five
six
seven
eight
nine
Not found 2 files
vagrant@vagrant:~/test$ exit
exit
vagrant@vagrant:~/test$
```

Также можно задать более запутанный путь, но без лишнего экземпляра `bash`:

```console
vagrant@vagrant:~/test$ cat {1..10}.dat 5>&1 >&2 2>&5 | echo "Not Found $(wc -l) files"
one
two
three
five
six
seven
eight
nine
Not Found 2 files
vagrant@vagrant:~/test$
```
В данном примере:

- `5>&1` - создаёт новый файловый дескриптов 5 и связывает его с `stdout`. То есть вывод `cat..` в ф.д. 5. Если этого не сделать, то текущий вывод потеряется.
   
- `>&2`  или `1>&2` - перенаправляется `stdout` на `stderr`. То есть ошибки `cat..` в ф.д. вывода
   
- `2>&5` - перенаправляется `stderr` на 5, что представляет собой `stdout`.

---

## 9. Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?

Данный файл содержит переменные окружения, установленные при запуске процесса (текущего), разделённых нулевым символом (`\0`)

Аналогичный вывод получится при исполнении следующей команды: `ps -o args= e $$ | sed -r 's/.{5}//' | tr -s ' ' '\0'`

*Для написания строки использовались руководства: `man proc`, `man ps`, `man sed`, `man tr`*

Команда `ps $$` выводит информацию о текущем процессе

Ключ `-o args=` задаёт произвольный формат вывода, а именно `args=`, то есть команду запуска со всеми аргументами, причём заголовок соответствующей колонки будет пуст. А если все колонки пустые, то строка заголовка выводиться не будет. (Обнудение всех заголовков можно заменить ключом `--no-headers` или его синонимом `--no-heading`)

ключ `e` дополняет команду запуска переменными окружения (то, что нам нужно)

Команда `sed` позволяет выполнить преобразование вывода в соответствии с шаблоном `s/.{5}//`, который означает удаление первых пяти символов первой строки (`-bash`). Ключ `-r` включает использование расширенного функционала регулярных выражений (без данного ключа выражение нужно было бы заменить на `s/.....//`)

Команда `tr` производит замену символов в режиме squeeze-repeats (`-s`), то есть заменить все повторяющиеся пробелы на символ NullByte `' ' '\0'`.

---

## 10. Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.

Файл `cmdline` доступен только для чтения и содержит полную командную строку запуска процесса со всеми параметрами, разделёнными нулевым символом (`\0`).
Если процесс в статусе зомби, то файл ничего не содержит и его размер равняется нуля. Запуск данного файла приведёт к запуску нового экземпляра программы.

Файл `exe` является символической ссылкой на исполняемый файл процесса. Но для ядра Linux 2.0 и ниже файл представляет собой указатель на исполняемый бинарный файл.

---

## 11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.

Наиболее удобный способ, как мне кажется, это использовать команду `grep`, так как она подсвечивает нужные фрагметы цветом (к, сожалению в MarkDown дополнительно подсветить вставку кода нельзя)

```console
vagrant@vagrant:~$ cat /proc/cpuinfo | grep sse -m1
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt rdtscp lm constant_tsc rep_good nopl nonstop_tsc cpuid extd_apicid tsc_known_freq pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx rdrand hypervisor lahf_lm cmp_legacy cr8_legacy abm sse4a misalignsse 3dnowprefetch ssbd vmmcall fsgsbase avx2 rdseed clflushopt arat
vagrant@vagrant:~$
```

Ответ: Если общую для Intel и AMD, то `SSE 4.2`. Но наиболее поздний набор `SSE4a`

---

## 12. Почему при исполнении `ssh localhost 'tty'` выводится надпись `not a tty` ? Как это исправить ?

Команда вида `ssh <host> '<command>'` создаёт сессию удалённого подключения к хосту `<host>` по протоколу SSH и исполняет в ней команду `<command>`. В нашем случае мы подключаемся к локальной машине (сами к себе) и выполняет команду `tty`.

В руководстве `man tty` указано, что она выводит имя файла терминала, связанного со стандартным вводом.

Следовательно выводимая фраза `not a tty` говорит, о том, что данные ресурсы не выделяются, что можно проверить следующей командой:

```console
vagrant@vagrant:~$ ssh localhost 'ls -l /proc/$$/fd/'
vagrant@localhost's password:
total 0
lr-x------ 1 vagrant vagrant 64 Feb 10 10:23 0 -> pipe:[34117]
l-wx------ 1 vagrant vagrant 64 Feb 10 10:23 1 -> pipe:[34118]
l-wx------ 1 vagrant vagrant 64 Feb 10 10:23 2 -> pipe:[34119]
lr-x------ 1 vagrant vagrant 64 Feb 10 10:23 3 -> /proc/2213/fd
vagrant@vagrant:~$
```

Данное поведение также указано в руководстве `man ssh` - при выполнении команды по умолчанию используется неинтерактивный режим, а без команды - интерактивный (с выделением соответствующих ресурсов). Также указано, что стандартное поведение можно изменить ключами `-T` (Выключить создание PTY) и `-t` (Включить создание PTY)

Таким образом, исправить поведение можно добавив ключ `-t`, а именно:

```console
vagrant@vagrant:~$ ssh localhost -t 'tty'
vagrant@localhost's password:
/dev/pts/1
Connection to localhost closed.
vagrant@vagrant:~$
```

---

## 13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.

Для начала утилиту нужно установить: `sudo apt-get install reptyr`

Для Ubuntu версии [Maverick](https://ru.wikipedia.org/wiki/Список_версий_Ubuntu#Выпуски) и выше учесть [ограничение работы системного вызова ptrace](https://github__com.teameo.ca/nelhage/reptyr#ptrace_scope-on-ubuntu-maverick-and-up), а именно до запуска `reptyr` выполнить команду: `echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope`, а после команду: `echo 1 | sudo tee /proc/sys/kernel/yama/ptrace_scope`

Пример переноса программы `htop` в `screen`

1. Запускаем программу `htop`
   
2. Сворачиваем в фонофой режим клавишами `Ctrl`+`Z`
   
   ```console   
   vagrant@vagrant:~$ htop

   [1]+  Stopped                 htop
   ```

3. Узнаём **PID** процесса `htop`, например командой `ps`
   
   ```console
   vagrant@vagrant:~$ ps
   PID TTY          TIME CMD
   1118 pts/0    00:00:00 bash
   1177 pts/0    00:00:00 htop
   1178 pts/0    00:00:00 ps
   vagrant@vagrant:~$
   ```

   либо через список текущих задач: `jobs -l`

   ```console
   vagrant@vagrant:~$ jobs -l
   [1]+  1177 Stopped                 htop
   vagrant@vagrant:~$
   ```
5. Отвязываем нашу задачу либо через номер задачи (`1`) командой `disown %1`, либо через **PID** `disown 1177`

   *Шаг не обязательный, так как без него результат одинаков, но данный пункт есть в инструкции `pertyr`*

   ```console
   vagrant@vagrant:~$ disown %1
   -bash: warning: deleting stopped job 1 with process group 1177
   vagrant@vagrant:~$
   ```

6. Запускаем программу `screen`
   
7. После ознакомления с инструкциями (нажимаем ENTER) запускаем `reptyr` с **PID** перепривязываемого процесса: `reptyr 1177`. Откроется окно программы `htop` в нормальном режиме

8. Отвязываем терминал монитора `screen` последовательным нажатием клавиш `Ctrl`+`A` и `D`
   
   ```consoel
   [detached from 1180.pts-0.vagrant]
   vagrant@vagrant:~$
   ```

9. Закрываем сессию SSH. Открываем снова.

10. Проверяем список процессов: `pstree -pT`

   ```console
   vagrant@vagrant:~$ pstree -pT
   systemd(1)─┬─VBoxService(892)
              ├─accounts-daemon(631)
              ├─atd(669)
              ├─cron(660)
              ├─dbus-daemon(632)
              ├─htop(1177)───htop(1196)
              ├─irqbalance(638)
              ├─login(687)───bash(963)
              ├─multipathd(529)
              ├─networkd-dispat(639)
              ├─polkitd(710)
              ├─rsyslogd(640)
              ├─screen(1180)───bash(1181)───reptyr(1195)
              ├─snapd(643)
              ├─sshd(663)───sshd(1202)───sshd(1242)───bash(1243)───pstree(1252)
              ├─systemd(957)───(sd-pam)(958)
              ├─systemd-journal(354)
              ├─systemd-logind(645)
              ├─systemd-network(614)
              ├─systemd-resolve(616)
              ├─systemd-udevd(384)
              └─udisksd(650)
   vagrant@vagrant:~$
   ```
   Наша запущенная задача никуда не делась, в списке присутствует `htop(1177)`, также открыт `screen(1180)` с процессом `reptyr(1195)`

11. Для того, чтобы вернуться в `screen` и привязанный к нему `htop` достаточно выполнить команду: `screen -r`.
    
    *Если было открыто несколько мониторов `screen`, то команда выдаст список имеющихся сессий, после чего нужно будет выполнить команду `screen -r <сессия>` с именем сессии в качестве параметра*

    ```console
    vagrant@vagrant:~$ screen -r
    There are several suitable screens on:
            1257.pts-0.vagrant      (02/11/2022 09:41:50 AM)        (Detached)
            1180.pts-0.vagrant      (02/11/2022 09:37:33 AM)        (Detached)
    Type "screen [-d] -r [pid.]tty.host" to resume one of them.
    vagrant@vagrant:~$
    ```

Стоит заметить, что утилита `reptyr` для перепривязки использует системный вызов функии `ptrace` в небезопасном режиме. По умолчанию, в целях безопасности на данный механизм наложены ограничения, которые не позволяют работать программе `reptyr` в нормальном режиме. Поэтому, на мой взгляд утилиту можно использовать только в крайних случаях и не забывать восстанавливать ограничения `ptrace` после работы с `reptyr`. Если есть возможность лучше завершить запущенный по ошибке процесс и открыть его заново в мониторе `screen`, `tmux` или других.

---

## 14. sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.

Команда `tee` производит чтение из `stdin` (стандартный поток ввода) и записывает в `stdout` (стандартный поток вывода). При указании имени файла в качестве параметра выполняет дополнительный вывод в указанный файл (или файлы если их несколько).

Команда `echo string | sudo tee /root/new_file` выполняется без ошибки, так как запись в файл выполняется программой `tee` с привилегиями `sudo` при которых доступ к каталогу `/root/` разрешён.

---

Использованные в лекции материалы:

- `$$` - **PID** текущего процесса

- `$PPID` - Переменная, содержащая **PID** родителя

- `pstree` - Вывод дерева процессов. `-p` с выводом **PID**, `-T` без вывода второстепенных процессов

- `jobs` - Вывод списка задач. `-l` с более подробной информацией

- `/dev` - файловое представление устройств

- `/proc` - файловое представление структур ядра

- `/proc/<PID>` - файловое представление структур процесса **PID**

- `whereis <программа>` - Вывод расположений файлов **программы**

- `which <программа>` - Вывод расположения бинарника **программы**

- `lsof` - Вывод списка открытых файловых дескрипторов. `-p <PID>` для процесса **PID**

- `evtest` - Тестирование устройств. Пример: `evtest /dev/input/event0`

- `tty` - Вывод файлового дескриптора текущего терминала
