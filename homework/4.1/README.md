# Домашнее задание по лекции "4.1. Командная оболочка Bash: Практические навыки"

## Обязательная задача 1

Есть скрипт:
```bash
a=1
b=2
c=a+b
d=$a+$b
e=$(($a+$b))
```
Какие значения переменным c,d,e будут присвоены? Почему?

| Переменная | Значение | Обоснование |
| --- | --- | --- |
| c | `a+b` | **Bash** считает выражение прокто текстом, так как нет специального символа `$` |
| d | `1+2` | Символы `$` указывают на использование переменных, то есть для **Bash** выражение примет логический вид: =`значение переменной a`+`значение переменной b`, то есть `1+2`, а так как в нём больше нет никаких специальных символов, обработка выражения прекращается |
| e | `3` | Первый символ `$` условно включает режим расчёта выражения внитри скобок `((`..`))` (арифметические операции), где складываются значения двух числовых переменных (пример выше - `1+2`). Другими словами скобки означают перевод выражения в сумма значений переменных, а не конкатенацию символов |

Выражение `$(($a+$b))` эквивалентно `$[$a+$b]`

---

## Обязательная задача 2

На нашем локальном сервере упал сервис и мы написали скрипт, который постоянно проверяет его доступность, записывая дату проверок до тех пор, пока сервис не станет доступным (после чего скрипт должен завершиться). В скрипте допущена ошибка, из-за которой выполнение не может завершиться, при этом место на Жёстком Диске постоянно уменьшается. Что необходимо сделать, чтобы его исправить:

```bash
while ((1==1)
do
	curl https://localhost:4757
	if (($? != 0))
	then
		date >> curl.log
	fi
done
```

Скрипт не сможет завершиться, так как цикл `while` не имеет точки выхода (выполняется бесконечно)

*Дополнено:* Также есть проблема быстрого накопления файла логов, так как выполняется непрерывная дозапись файла (`>>`). Исправить можно либо добавлением существенной паузы между проверками, либо перезаписью файла (`>`)

Ответ (Рабочий вариант скрипта):

```bash
while ((1==1))
do
  curl https://localhost:4757
  if (($? != 0))
  then
    date > curl.log
  else
    break
  fi
done
```

---

## 3. Обязательная задача 3

Необходимо написать скрипт, который проверяет доступность трёх IP: `192.168.0.1`, `173.194.222.113`, `87.250.250.242` по `80` порту и записывает результат в файл `log`. Проверять доступность необходимо пять раз для каждого узла.

```bash
#!/bin/env bash

url=("192.168.0.1:80" "173.194.222.113:80" "87.250.250.242:80")
max_check=5

for i in $(seq $max_check)
do
  log=
  echo "--- Wave $i ---"
  for lnk in ${url[@]}
  do
    echo "Checking $lnk"
    curl -s $lnk >/dev/null
    if (($? == 0))
    then
      res="Good"
    else
      res="Bad"
    fi
    log+=" $lnk=$res "
  done
  echo $log >> log
done
```

Выражение `for i in $(seq $max_check)` эквивалентно `for ((i=1;i<=$max_check;i++))`

---

## Обязательная задача 4

Необходимо дописать скрипт из предыдущего задания так, чтобы он выполнялся до тех пор, пока один из узлов не окажется недоступным. Если любой из узлов недоступен - IP этого узла пишется в файл error, скрипт прерывается.

Так как скрипт останавливается при выявлении недоступного адреса, то есть ведёт журнал сбоев, то ведение журнала успешных проверок становится избыточным, поэтому соответствующий код был удалён

```bash
#!/bin/env bash

url=("192.168.0.1:80" "173.194.222.113:80" "87.250.250.242:80")

goexit=0
until ((goexit>0))
do
  for lnk in ${url[@]}
  do
    echo "Checking $lnk"
    curl -s $lnk >/dev/null
    if (($? != 0))
    then
      echo $lnk >> error
      goexit+=1
      break
    fi
  done
done
```

Выражение `until ((goexit>0))` эквивалентно `while ((goexit == 0))`

---

## Дополнительное задание (со звездочкой*)

Мы хотим, чтобы у нас были красивые сообщения для коммитов в репозиторий. Для этого нужно написать локальный хук для git, который будет проверять, что сообщение в коммите содержит код текущего задания в квадратных скобках и количество символов в сообщении не превышает 30. Пример сообщения: \[04-script-01-bash\] сломал хук.

Проверка сообщения выполняется в хуке `commit-msg`. Следовательно для активации данного хука нужно скопировать или переименовать файл `.git/hooks/commit-msg.sample` в `.git/hooks/commit-msg` (удалить расширение `.sample`). После чего его содержимое заменить следующим:

```bash
#!/bin/env bash

comment=$(cat $1)

if [[ ${#comment} -gt 30 ]]
then
  echo "Слишком длинное описание коммита"
  exit 1
fi

if [[ ! $comment =~ ^\[([0-9]{1,3})-([A-Za-z]+)-([0-9]+)-([A-Za-z]+)\]\ .* ]]
then
  echo "Недопустимый формат описания коммита"
  exit 2
fi
```

Альтернативный вариант в однострочном стиле:

```bash
#!/bin/env bash
comment=$(cat $1); [[ ${#comment} -gt 30 ]] && echo "Слишком длинное описание коммита" && exit 1; [[ ! $comment =~ ^\[([0-9]{1,3})-([A-Za-z]+)-([0-9]+)-([A-Za-z]+)\]\ .* ]] && echo "Недопустимый формат описания коммита" && exit 2
```

Альтернативный вариант с одним условием:

```bash
#!/bin/env bash
comment=$(cat $1); [[ ${#comment} -le 30 ]] && [[ $comment =~ ^\[([0-9]{1,3})-([A-Za-z]+)-([0-9]+)-([A-Za-z]+)\]\ .* ]] && exit 0; echo "Ошибка в комментарии. Максимальная длина: 30. Формат: [nn-task-nn-stage] text"
```

Для проверки комментария использовалось регулярное выражение: `^\[([0-9]{1,3})-([A-Za-z]+)-([0-9]+)-([A-Za-z]+)\]\ .*`, означающее следующее (последовательно):

- С начала строки символ `[`

- от 1 до 3 числовых символов от 0 до 9

- Символ `-`

- Не менее одного текстового символа из наборов `A-Z` и `a-z`

- Символ `-`

- Не менее одного числового символа от 0 до 9

- Символ `-`

- Не менее одного текстового символа из наборов `A-Z` и `a-z`

- Символы `] `

- Произвольное количество любых символов (`.*`)

> Использовалась статья: [Регулярные выражения в командной строке Bash](https://serverspace.ru/support/help/regulyarnye-vyrazheniya/)
